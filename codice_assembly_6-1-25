;   Autore: 
;   Nicola Ferri, num. matricola:1109906
;   Marco Mazzarini, num. matricola: 1109734
;
;
;                             DESCRIZIONE
;   Si realizzi un firmware che faccia scorrere un LED acceso da destra a sinistra e 
;   viceversa; dei comandi ricevuti dalla porta seriale (USART) permettano di aumentare 
;   e diminuire la velocità di scorrimento, e arrestare e far ripartire il lampeggio.
;   Descrizione hardware:
;   - scheda Cedar "Pic Board - Studio" 
;   - MCU: PIC16F887 (clock interno 2 MHz)




PROCESSOR 16F887    ; direttiva che definisce il tipo di processore
#include <xc.inc>   ; file che contiene le definizioni dei simboli (nomi registri, nomi bit dei registri, ecc).
; configuration bits
CONFIG "FOSC = INTRC_NOCLKOUT"    ; Oscillatore interno abilitato, senza uscita clock
CONFIG "CP = OFF"                ; Protezione codice disabilitata
CONFIG "CPD = OFF"               ; Protezione dati EEPROM disabilitata
CONFIG "WDTE = OFF"              ; Watchdog Timer disabilitato
CONFIG "BOREN = OFF"             ; Brown-out Reset disabilitato
CONFIG "PWRTE = OFF"             ; Power-up Timer disabilitato
CONFIG "LVP = OFF"               ; Programmazione a bassa tensione disabilitata
CONFIG "DEBUG = OFF"             ; Debugger disabilitato
CONFIG "BOR4V = BOR21V"          ; Brown-out Reset a 2.1V
CONFIG "WRT = OFF"               ; Protezione scrittura Flash disabilitata

 
PSECT udata_shr                       ; direttiva che definisce una nuova sezione di memoria condivisa
; Variabili utilizzate per salvare lo stato della CPU all'ingresso dell'ISR
    w_temp:	         DS 1             ; Temporanea per il registro W
    status_temp:     DS 1             ; Temporanea per STATUS
    pclath_temp:     DS 1             ; Temporanea per PCLATH
    output_led:	     DS 1             ; variabile che conserva in memoria lo stato dei led
    direction:	      DS 1             ; variabile che conserva in memoria la direzione di scorrimento: 0 = direzione sinistra, 1=direzione destra
    tmp:	            DS 1
    pause_flag:	     DS 1             ; Flag di pausa (1 = pausa, 0 = rotazione)
    low_tmr_1000ms:  DS 1             ; variabile per il conteggio iniziale del timer1 da inserire nel TMR1L
    high_tmr_1000ms:	DS 1             ; variabile per il conteggio iniziale del timer1 da inserire nel TMR1H
    delta:	          DS 1             ; variabile temporale che viene sommata o sottratta alle variabili caricate nel timer1 a seconda del pulsante ceh è stato premuto
    
; Reset vector
; Il vettore di reset è l'istruzione che viene eseguita per prima dopo un reset del microcontrollore.
; La direttiva CODE dichiara una sezione di codice da allocare in ROM.Un delta di 2 significa che 
; le istruzioni in questa sezione saranno allineate a parole di 2 byte

PSECT reset_vec,class=CODE,delta=2
reset_vec:
   pagesel	start			                   ; imposta la pagina della memoria di programma in cui si trova l'indirizzo della label start
			goto	start			                      ; salta all'indirizzo indicato dalla label start


; PROGRAMMA PRINCIPALE
PSECT MainCode,global,class=CODE,delta=2
start:
    ; Configurazione oscillatore interno
    banksel OSCCON                   ; banco di OSCCON                   
    movlw   01010001B                ; carica costante binaria 01011001 in w
    movwf   OSCCON                   ; copia w in OSCCON, con la combinazione dei bit 6-5-4, IRCF <2:0>, configuro la frequenza del clock interno a 2 MHz

    ; Abilitazione sorgenti di interrupt 
    banksel INTCON                   ; banco di INTCON
    movlw   11000000B                ; carica costante binaria 11000000 in w
    movwf   INTCON                   ; copia w in INTCON, setto il global interrupt enable e il peripheral interrupt enable

    ; Configurazione Timer1
    banksel T1CON                   ; banco di T1CON
    movlw   00110001B               ; carica costante binaraia 00110001 in w
    movwf   T1CON                   ; copia w in T1CON: bit-0 ovvero TMR1ON=1 abilita il timer1, bit-1 TMR1CS=0, seleziona come sorgente di clock quella interna(Fosc/4), 
                                    ;con i bit 5-4 T1CKPS<1:0> imposto un prescarler pari a 8, 
    clrf    TMR1L  
    clrf    TMR1H
    

    ; Configurazione PORTD come output
    banksel TRISD                   ; banco di TRISD
    clrf TRISD                      ; in questo modo forzando tutti i bit a 0, configuro tutti i led come output 

    ; Configura PORTD
    banksel PORTD                   ; banco di PORTD
    movlw 0x01                      ; carica costante binaria 0x01 in w, per accendere il primo led 
    movwf PORTD                     ; copia w in PORTD
    
    ; Configurazione interrupt
    banksel PIR1                    ; banco di PIR1
    clrf PIR1                       ; Azzera tutti i flag
    
    banksel PIE1                    ; banco di PIE1
    movlw 00100001B                 ; carica costante variabile 00100001 in w, per abilitare le richieste di interrupt dell'usart in ricezione e quelle generate dall'overflow del timer1 
    movwf PIE1                      ; copia w in PIE1
      
    ;Configurazione USART
    banksel TXSTA                   ; banco di TXSTA
    movlw 00000110B                 ; carica costante variabile 00000110 in w. Azzera il bit SYNC in modo tale che la porta seriale lavori in modalità asincrona, mentre setta il bit BRGH(high speed) 
    movwf TXSTA                     ; copia w in TXSTA
    
    banksel RCSTA                   ; banco di RCSTA
    movlw 10010000B                 ; carica costante variabile 10010000 in w. Setta il bit SPEN, abilitando il bit di abilitazione della porta seriale, setta il bit CREN, abilitando la ricezione in modalità asincrona 
    movwf RCSTA                     ; copia w in RCSTA
    
    banksel BAUDCTL                 ; banco di BAUDCTL
    clrf BAUDCTL                    ; azzera il bit BRG16, quindi utilizza un generatore di baud rate a 8 bit
    
    banksel SPBRG                   ; banco di SPBRG
    movlw 12                        ; carica 12(valore ricavato dalle tabelle del datasheet) in w, per avere un baud rate pari a 9600
    movwf SPBRG                     ; copia w in SPBRG
    
     ; Inizializza il registro per la rotazione LED
    banksel output_led
    movlw 0x01                    ; Imposta il primo LED acceso (LED0)
    movwf output_led
    
    banksel direction
    clrf direction    ; 0 = direzione sinistra
    
    banksel low_tmr_1000ms
    movlw 128
    movwf low_tmr_1000ms
    
    banksel high_tmr_1000ms
    movlw 128
    movwf high_tmr_1000ms
    
    banksel delta
    movlw 50
    movwf delta
    
    
main_loop:
    goto main_loop                ; Loop principale (gli interrupt gestiscono il resto)

; Funzione MOVE_LED: Rotazione dei LED
MOVE_LED:
    banksel pause_flag
    movf pause_flag, w         ; Controlla se la pausa è attiva
    btfsc STATUS, STATUS_Z_POSITION
    return                     ; Se pausa_flag è 1, esci (stoppa la rotazione)

    banksel direction
    movf direction, w         ; Leggi la direzione corrente
    btfsc STATUS,STATUS_Z_POSITION           ; Se Z=0 (direzione=0), esegui shift sinistra
    goto shift_left           ; Altrimenti, shift destra

shift_right:
    bcf STATUS, STATUS_C_POSITION ; Azzeramento carry
    rrf output_led, f             ; Shift a destra con carry
    btfss output_led, 0           ; Se il bit 0 è acceso, cambia direzione
    goto led_ok
    ; Cambia direzione a sinistra
    movlw 0x01
    movwf output_led
    banksel direction
    clrf direction                ; Imposta direzione = sinistra
    goto led_ok

shift_left:
    bcf STATUS, STATUS_C_POSITION ; Azzeramento carry
    rlf output_led, f             ; Shift a sinistra con carry
    btfss output_led, 4           ; Se il bit 4 è acceso, cambia direzione
    goto led_ok
    ; Cambia direzione a destra
    movlw 0x04
    movwf output_led
    banksel direction
    movlw 0x01
    movwf direction               ; Imposta direzione = destra

led_ok:
    movf output_led, w            ; Aggiorna PORTD
    banksel PORTD
    movwf PORTD
    return

; Funzione RELOAD_TIMER1: Ricarica il timer per 1 secondo
reload_timer1:
    banksel T1CON
    bcf T1CON, T1CON_TMR1ON_POSITION  ; Arresta il timer

    banksel low_tmr_1000ms
    movf low_tmr_1000ms, w
    movwf TMR1L                     ; Carica il valore basso

    banksel high_tmr_1000ms
    movf high_tmr_1000ms, w
    movwf TMR1H                     ; Carica il valore alto

    banksel PIR1
    bcf PIR1, PIR1_TMR1IF_POSITION  ; Azzera il flag interrupt Timer1

    banksel T1CON
    bsf T1CON, T1CON_TMR1ON_POSITION ; Riattiva il timer
    return


; Funzione per mettere in pausa
pausa:
    banksel T1CON
    bcf T1CON, T1CON_TMR1ON_POSITION  ; Arresta il timer
    banksel pause_flag
    movlw 1
    movwf pause_flag               ; Setta il flag di pausa
    banksel PIR1           ; Seleziona la banca contenente PIR1
    bcf PIR1, PIR1_RCIF_POSITION ; Resetta il flag RCIF (bit 5 di PIR1)
    return

; Funzione per riprendere
restart:             ; Resetta il flag di pausa         
    banksel PORTD
    movf output_led, w 
    movwf PORTD
    banksel PIR1           ; Seleziona la banca contenente PIR1
    bcf PIR1, PIR1_RCIF_POSITION
    banksel T1CON
    bsf T1CON, T1CON_TMR1ON_POSITION  ; Riattiva il timer
    return

accelera_shift_led:                  ; Se pausa_flag è 1, esci (stoppa la rotazione)
    banksel low_tmr_1000ms
    movf low_tmr_1000ms, w
    addwf delta, w
    btfsc STATUS,STATUS_C_POSITION   ; Controlla se c'è stato un carry (overflow)
    movlw 220			      ; Se sì, forza il valore massimo
    movwf low_tmr_1000ms
    banksel high_tmr_1000ms
    movf high_tmr_1000ms, w
    addwf delta, w
    btfsc STATUS,STATUS_C_POSITION
    movlw 220
    movwf high_tmr_1000ms
    call reload_timer1
    return
    

rallenta_shift_led:
    ; Diminuisci low_tmr_1000ms
    banksel low_tmr_1000ms
    movf low_tmr_1000ms, w       ; Carica il valore corrente
    subwf delta, w               ; Sottrai il valore di delta
    btfsc STATUS, STATUS_C_POSITION ;
    movlw 0
    movwf low_tmr_1000ms; Aggiorna il timer
    banksel high_tmr_1000ms
    movf high_tmr_1000ms, w
    subwf delta, w 
    btfsc STATUS, STATUS_C_POSITION ; Se il risultato è positivo
    movlw 0
    movwf high_tmr_1000ms
    call reload_timer1
    return


    
; Gestione interrupt
PSECT isrVec,class=CODE,delta=2
isr:
    movwf w_temp                   ; Salva registro W
    swapf STATUS, w
    movwf status_temp              ; Salva STATUS
    movf PCLATH, w
    movwf pclath_temp              ; Salva PCLATH

test_timer1:
    banksel PIR1
    btfss PIR1, PIR1_TMR1IF_POSITION
    goto test_usart                ; Se non è Timer1, controlla se l'interrupt è stato generato dall'usart 
    call MOVE_LED                  ; Ruota i LED
    call reload_timer1             ; Ricarica il timer1             

test_usart:    ;controllo se l'interrupt è stato generato dalla porta seriale
    banksel PIR1
    btfss PIR1,PIR1_RCIF_POSITION
    goto irq_end
    banksel RCREG
    movf RCREG,w
    movwf tmp         ; memorizza byte ricevuto in "tmp"
    ; interpretazione comando
    movlw 'p'
    subwf tmp,w
    btfsc STATUS,STATUS_Z_POSITION    ; confronta tmp con 'p'
    call pausa   ; se uguale, chiama pausa
    movlw 'r'
    subwf tmp,w
    btfsc STATUS,STATUS_Z_POSITION    ; confronta tmp con 'r'
    call restart
    movlw '+'
    subwf tmp,w
    btfsc STATUS,STATUS_Z_POSITION    ; confronta tmp con 'p'
    call accelera_shift_led  ; se uguale, chiama accelera_shift_led
    movlw '-'
    subwf tmp,w
    btfsc STATUS,STATUS_Z_POSITION    ; confronta tmp con 'p'
    call rallenta_shift_led   ; se uguale, chiama rallensta_shift led
    goto irq_end
    

irq_end:
    ; Ripristina registri
    swapf status_temp, w
    movwf STATUS
    swapf w_temp, f
    swapf w_temp, w
    retfie

END reset_vec
